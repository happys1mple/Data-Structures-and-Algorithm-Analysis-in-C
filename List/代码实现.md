# c线性表的结构体定义和基本操作

## 结构体定义

```c
#ifndef _list-H

struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode List;
typedef PtyToNode Position;
```



```c
struct
{
    ElementType data[maxSize];  //存放顺序表的数组（可换成其他类型）
    int length;	//存放顺序表的长度
}Sqlist;	//顺序表类型定义
```

```c
struct Node
{
	ElementType Element;		//存放节点数据域
	Position Next;			//指向后继结点的指针
} //单链表结点定义
```

```c
typedef struct DLNode
{
	ElementType Element;		//存放节点数据域
	Position *prior;
	Position *next;
}//双链表结点定义
```

```c
LNode *A = (LNode*)malloc(sizeof(LNode));
```

分配了一片LNode型空间；A命名了两个东西：一个是结点，另一个是指向这个结点的指针。 



## 顺序表的操作

### 已知一个顺序表L，其中元素有序递增排列，设计一个算法，插入一个元素x（int）后保持改顺序表仍然递增有序排列

操作一:

```c
int findElem (Sqlist L, int x)
{
	int i;
	for(i=0;i<L.length;i++);
	{
		if(x<L.data[i])
        {
            return i;		//如果小于则返回当前位置i
        }
	}
    return i;		//表中不存在比x大的元素,i指示了表尾元素
}//返回第一个比x大的元素位置
```

操作二:先移动最右边的元素,如果先移动最左边的元素,则右边的元素会被左边的元素所覆盖.

```c
void inserElem(Sqlist &L, int x)
{
	int p, i;
	p = findElem(L,x);
	for(i=L.length-1;i>=p;--i);
		L.data[i+1]=L.data[i];
	L.data[p]=x;
	++(L.length);
}
```



## 链表的操作

```c
int IsEmpty(List L)
{
    return L->Next == NULL;
}//测试一个链表是否是空表
```

```c
int IsLast(Position P, List L)
{
	return P->Next == NULL;
}//测试当前位置是否是链表的末尾
```

```c
Position Find(ElemenType X, List L)
{
	Position P;
	
	P = L->Next;
	while(P!=NULL && P->Element != X)
        P=P->Next;
    
    return P;
}//Find
```

```c
void Delete(ElementType X, List L)
{
    Position P, TmpCell;
    
    P=FindPrevious(X,L);
    if(!IsLast(P,L))
    {
        TmpCell = P->Next;
        P-Next = TmpCell->Next;
        free(TmpCell);
    }
}//链表的删除
```

```c
Position FindPrevious(ElementType X, List L)
{
    Position P;
    
    P=L;
    while(P->Next != NULL && P->Next->Element != X)
        P=P->Next;
    
    return P;
}//FindPrevious
```

```c
void Insert(ElementType X, List L, Position P)
{
	Position TmpCell;
    
    TmpCell = malloc(sizeof(struct Node));
    if(TmpCell == NULL)
        FatalError("Out of space!!!!");
    TmpCell->Element = X;
    TmpCell->Next = P->Next;
    P->Next = TmpCell;
}//链表的插入
```

### 常见错误:

1.程序因来自系统的错误信息而崩溃,比如"memory access violation"或"segmentation violation",这种信息通常意味着有指针变量包含了伪地址.

2.涉及何时使用或何时不使用malloc来获取一个新的单元.



## 相关问题

### LC设计链表

> https://leetcode-cn.com/leetbook/read/linked-list/jy291/

计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。。

- get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

 **示例：**

```c
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

**提示：**

- 所有`val`值都在 `[1, 1000]` 之内。
- 操作次数将在 `[1, 1000]` 之内。
- 请不要使用内置的 LinkedList 库。

```c
struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;
struct Node
{
    int Element;
    Position Next;
};

int main() {
    printf("Hello, World!\n");
    return 0;
}

int get(List obj, int index)
{
    if(!obj ||index<0)
        return -1;
    PtrToNode P=obj->Next;
    for(int j=0; j<index;j++){
        if(!P->Next)
            return -1;
        P = P->Next;
    }
    return P->Element;
}
int addAtHead(List obj, int val)
{
    PtrToNode P,TmpCell;
    P = obj;
    TmpCell = (PtrToNode)malloc(sizeof(struct Node));
    if(!TmpCell)
        return -1;
    TmpCell->Element = val;
    TmpCell->Next = P->Next;
    P->Next = TmpCell;
}
void addAtTail(List obj, int val){
    PtrToNode newNode = (PtrToNode)malloc(sizeof(PtrToNode));
    newNode->Element = val;

    PtrToNode P = obj;
    while (P->Next){
        P=P->Next;
    }
    P->Next = newNode;
    newNode->Next = NULL;
}
void addAtIndex(int index, int val, List obj){
    int Count=0;
    if(index < 0)
        addAtHead(obj,val);
    PtrToNode P = obj;
    while(P->Next)
    {
        P=P->Next;
        Count++;
    }
    if (index == Count)
        addAtTail(obj,val);
    if (index > Count)
        return;
}
void deleteAtIndex(int index, List obj){
    if(!obj ||index<0)
        return;
    PtrToNode P = obj->Next;
    for(int j=0; j<index-1;j++) {
        if (!P->Next)
            return;
        P = P->Next;
    }
    PtrToNode TmpCell;
    TmpCell = P->Next;
    P->Next = P->Next->Next;
    P=P->Next;
    free(P);
}
```



## 双指针技巧

### LC环行链表

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。



**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？



**示例 1：**

![circularlinkedlist](E:\Work&study\究极学习\Data-Structures-and-Algorithm-Analysis-in-C\.git\Data-Structures-and-Algorithm-Analysis-in-C\circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 方法：快慢指针

我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 `head`，而快指针在位置 `head.next`。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```C
typedef int bool;
#define Ture 1
#define False 0
bool hasCycle(PtrToNode head) {
    if (head == NULL || head->Next == NULL) {
        return False;
    }
    PtrToNode slow = head;
    PtrToNode fast = head->Next;
    while (slow != fast){
        if (fast == NULL || fast->Next == NULL){
            return False;
        }
        slow = slow->Next;
        fast = fast->Next->Next;
    }
    return Ture;
}
```



### LC 环形链表 II

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。



**进阶：**

- 你是否可以使用 `O(1)` 空间解决此题？



**示例 1：**

![circularlinkedlist](E:\Work&study\究极学习\Data-Structures-and-Algorithm-Analysis-in-C\.git\Data-Structures-and-Algorithm-Analysis-in-C\circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

```C
PtrToNode detectCycle(PtrToNode head){
    PtrToNode slow = head;
    PtrToNode fast = head;
    while (fast != NULL)
    {
        slow = slow->Next;
        if (fast->Next == NULL){
            return NULL;
        }
        fast = fast->Next->Next;
        if (fast == slow){
            PtrToNode ptr = head;
            while (ptr != slow){
                ptr = ptr->Next;
                slow = slow->Next;
            }
            return ptr;
        }
    }
}
```

